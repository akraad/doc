#!/usr/bin/env bash
# MyCrash.sh — Runtime crash catcher (macOS-safe, BSD awk compatible)

set +e
OUT="${OUT:-Crash-Report.txt}"
TIMEOUT="${TIMEOUT:-120}"
MONITOR=0
PKG=""

# Args: --package com.example.app  --timeout 180  --out file  --monitor
while [ $# -gt 0 ]; do
  case "$1" in
    --out) OUT="$2"; shift 2;;
    --timeout) TIMEOUT="$2"; shift 2;;
    --monitor) MONITOR=1; shift;;
    --package) PKG="$2"; shift 2;;
    *) shift;;
  esac
done

die(){ echo "ERROR: $*" >&2; exit 1; }
rel(){ p="$1"; case "$p" in /*) p="${p#"$PWD/"}";; esac; echo "${p#./}"; }
esc_sed(){ printf '%s' "$1" | sed 's/[][(){}.^$+*?|\\/]/\\&/g'; }

# Try to auto-detect applicationId if not provided
if [ -z "$PKG" ]; then
  PKG="$(grep -Rho --include='build.gradle' --include='build.gradle.kts' "applicationId[[:space:]]\+['\"][^'\"]\+['\"]" . 2>/dev/null | head -n1 | sed -E 's/.*["'\'']([^"'\'']+)["'\''].*/\1/')" || true
fi

if [ -z "$PKG" ]; then
  echo "Note: --package not provided and applicationId not found. Will catch ANY process crashes."
fi

command -v adb >/dev/null 2>&1 || die "adb not found in PATH"
adb get-state >/dev/null 2>&1 || die "No device/emulator detected"

MODEL="$(adb shell getprop ro.product.model | tr -d '\r')"
SDK="$(adb shell getprop ro.build.version.sdk | tr -d '\r')"
ANDROID="$(adb shell getprop ro.build.version.release | tr -d '\r')"

adb logcat -c >/dev/null 2>&1

# Prefer gtimeout (coreutils) if available; fallback to timeout; else none
if [ "$MONITOR" -eq 0 ]; then
  if command -v gtimeout >/dev/null 2>&1; then TO=(gtimeout "$TIMEOUT")
  elif command -v timeout  >/dev/null 2>&1; then TO=(timeout "$TIMEOUT")
  else TO=() ; fi
else
  TO=()
fi

# Escape pattern for awk match
PKGRE="$(esc_sed "$PKG")"

# Run logcat and parse with BSD awk-safe script (no C-style comments)
"${TO[@]}" adb logcat -v threadtime *:V | awk -v out="$OUT" -v pkg="$PKG" -v pkgre="$PKGRE" -v monitor="$MONITOR" -v model="$MODEL" -v sdk="$SDK" -v android="$ANDROID" '
BEGIN{
  N=200; head=0; fill=0; sep="---";
  firstCrash=1;
  print "" > out; close(out);
}
function push(line){ buf[head]=line; head=(head+1)%N; if(fill<N) fill++; }
function dump_context(outf){
  print "=== Context (last ~200 lines) ===" >> outf;
  for(i=head-fill;i<head;i++){ idx=(i+N)%N; print buf[idx] >> outf; }
}
function write_header(outf, kind, title){
  print "Device: " model " | Android " android " (SDK " sdk ")" >> outf;
  if(pkg!="") print "Package: " pkg >> outf;
  print "Type: " kind >> outf;
  print "Title: " title >> outf;
  print sep >> outf;
}
function top_app_frames(stack,   i, line, outl, cnt){
  cnt=0; split(stack, arr, "\n");
  for(i=1;i<=length(arr);i++){
    line=arr[i];
    if(pkg=="" || line ~ pkgre){
      if(line ~ /^ *at /){
        outl=outl line "\n"; cnt++;
        if(cnt>=6) break;
      }
    }
  }
  if(cnt==0) return "(no app frames)\n";
  return outl;
}
function handle_java(outf){
  write_header(outf, "Java FATAL EXCEPTION", fatalTitle);
  if(threadLine!="") print "Thread: " threadLine >> outf;
  print sep >> outf;
  print "Exception:" >> outf;
  print fatalTitle >> outf;
  if(causedBy!="") print causedBy >> outf;
  print sep >> outf;
  print "Top app frames:" >> outf;
  print top_app_frames(stackBlock) >> outf;
  print sep >> outf;
  dump_context(outf);
  print "" >> outf; print "" >> outf;
}
function handle_native(outf){
  write_header(outf, "Native Crash", nativeTitle);
  print sep >> outf;
  print "Backtrace (excerpt):" >> outf;
  print nativeTrace >> outf;
  print sep >> outf;
  dump_context(outf);
  print "" >> outf; print "" >> outf;
}
function handle_anr(outf){
  write_header(outf, "ANR", anrTitle);
  print sep >> outf;
  print "Details:" >> outf;
  print anrBlock >> outf;
  print sep >> outf;
  dump_context(outf);
  print "" >> outf; print "" >> outf;
}

{
  line=$0;
  push(line);

  # Java/Kotlin fatal exception
  if(index(line,"FATAL EXCEPTION:")>0){
    fatalTitle=line; threadLine=""; causedBy=""; stackBlock="";
    while( (getline l) > 0 ){
      push(l);
      if(l ~ /^$/) break;
      if(pkg!="" && l ~ /Process:/ && l !~ pkgre) { }  # ignore other processes only when pkg is set
      if(l ~ /^ *at / || index(l,"Caused by:")==1 || index(l,"Exception")>0 ){
        stackBlock = stackBlock l "\n";
        if(index(l,"Caused by:")==1 && causedBy==""){ causedBy=l }
      }
      if(l ~ /" (main|[^"]+)"/ || l ~ /pid=/ ){ threadLine=l }
      fatalTitle = fatalTitle "\n" l
    }
    if(pkg=="" || fatalTitle ~ pkgre || stackBlock ~ pkgre){
      handle_java(out);
      if(!monitor) exit;
    }
  }

  # Native crash (tombstoned/backtrace/fatal signal)
  if(line ~ /(Fatal signal|backtrace:|tombstoned:)/){
    nativeTitle=line;
    nativeTrace=line "\n";
    for(i=0;i<80;i++){
      if( (getline l2) <= 0 ) break;
      push(l2);
      nativeTrace = nativeTrace l2 "\n";
      if(l2 ~ /backtrace ends|--------- beginning of/) break;
    }
    if(pkg=="" || nativeTrace ~ pkgre){
      handle_native(out);
      if(!monitor) exit;
    }
  }

  # ANR block
  if(index(line,"ANR in ")==1){
    if(pkg!="" && line !~ ("ANR in " pkgre)) { next }
    anrTitle=line; anrBlock=line "\n";
    for(i=0;i<120;i++){
      if( (getline l3) <= 0 ) break;
      push(l3);
      anrBlock = anrBlock l3 "\n";
      if(l3 ~ /^$/) break;
    }
    handle_anr(out);
    if(!monitor) exit;
  }
}
END{
  if(monitor==0){
    if(system("[ -s " out " ]")!=0){
      print "No runtime crash captured within timeout." > out
    }
  }
}
'

echo "Report → $(rel "$OUT")"
